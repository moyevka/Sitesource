<!-- links -->
<link rel="manifest" href="/assets/site/site.webmanifest">
<link rel="shortcut icon" href="/assets/site/favicon.ico">
<link rel="stylesheet" href="\css\global.css">
<link rel="preload" href="\css\fonts\MatissePixelated.woff2" as="font" crossorigin>
<link rel="preload" href="\css\fonts\MatissePixelated.woff" as="font" crossorigin>

<!-- Montserrat -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

<!-- DM Sans -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&display=swap" rel="stylesheet">

<!-- pixel filter -->
<svg class="offscreen" width="0" height="0" xmlns="http://www.w3.org/2000/svg">
    <defs>
        <filter id="binary">
            <feComponentTransfer>
                <feFuncA type="discrete" tableValues="0 1"/>
            </feComponentTransfer>
        </filter>
    </defs>
</svg>

<!-- whiteout opener -->
<script>
const splash = document.createElement('div');
splash.classList.add('opener');
document.body.appendChild(splash);

function removeSplash(){
    const splash = document.querySelector('.opener');
    if (splash) {
        splash.style.opacity = '0';
        setTimeout(() => {
            splash.remove();
        }, 1000);
    }
}
</script>

<!-- postboard -->
<script>
function rand(min, max) {
    return Math.random() * (max - min) + min;
}

function postGallery() {
    const gallery = document.querySelector('.post-gallery');
    if (gallery) {
        const postItems = document.querySelectorAll('.post-gallery .post-item');
        let zIndexes = Array.from({ length: postItems.length }, (_, i) => i + 1);

        // Check if the gallery.id includes 'randomSort'
        const randomSort = gallery.id.includes('randomSort');

        if (gallery.id.includes('scatterPlace')) {
            scatterPlace(postItems);
        }

        if (gallery.id.includes('clusterPlace')) {
            clusterPlace(postItems);
        }

        // Pass randomSort to hoverSort
        hoverSort(postItems, randomSort);

        postItems.forEach(post => {
            if (post.querySelector('img.movable')) {
                dragMove(post);
            }
        });
    }
}

function scatterPlace(postItems) {
    const numPosts = postItems.length;
    const numBottomScatter = Math.floor(numPosts / 3);
    const numCurveScatter = numPosts - numBottomScatter;

    const shuffledItems = [...postItems].sort(() => Math.random() - 0.5);

    const bottomScatter = shuffledItems.slice(0, numBottomScatter);
    const curveScatter = shuffledItems.slice(numBottomScatter);

    const halfBottomScatter = Math.floor(numBottomScatter / 2);
    const bottomLeftScatter = bottomScatter.slice(0, halfBottomScatter);
    const bottomRightScatter = bottomScatter.slice(halfBottomScatter);

    // Formula for bottomScatter placement, normalized to the specified bounds
    function getNormalizedPosition(index, xBoundMin, xBoundMax, yBoundMin, yBoundMax) {
        index += 1; // Increment the index to avoid (0, 0) placement
        let x = (index * 0.245122333753) % 1; // Normalize to [0, 1]
        let y = (index * 0.430159709002) % 1; // Normalize to [0, 1]

        x = xBoundMin + x * (xBoundMax - xBoundMin); // Normalize to bounds
        y = yBoundMin + y * (yBoundMax - yBoundMin);

        return { x, y };
    }

    bottomLeftScatter.forEach((post, index) => {
        const { x, y } = getNormalizedPosition(index, 0, 0.2, 0.4, 0.9);
        post.dataset.x = -x + 0.1;
        post.dataset.y = y;
    });

    bottomRightScatter.forEach((post, index) => {
        const { x, y } = getNormalizedPosition(index, 0.8, 1.2, 0.4, 0.9);
        post.dataset.x = x;
        post.dataset.y = y;
    });

    curveScatter.forEach((post, index) => {
        const t = index / (numCurveScatter - 1);

        const x = Math.pow(1 - t, 3) * 0 +
                  3 * Math.pow(1 - t, 2) * t * 0 +
                  3 * (1 - t) * Math.pow(t, 2) * 1 +
                  Math.pow(t, 3) * 1;

        const y = Math.pow(1 - t, 3) * 0 +
                  3 * Math.pow(1 - t, 2) * t * 1 +
                  3 * (1 - t) * Math.pow(t, 2) * 1 +
                  Math.pow(t, 3) * 0;

        post.dataset.x = x;
        post.dataset.y = y;
    });

    // Set final position and rotation for all posts after indexing
    postItems.forEach(post => {
        const randomRotation = rand(-3, 3);

        const jitterX = rand(-0.03,0.03);
        const jitterY = rand(-0.03,0.03);

        const xJittered = parseFloat(post.dataset.x) + jitterX;
        const yJittered = parseFloat(post.dataset.y) + jitterY;

        post.style.position = 'absolute';
        post.style.left = `${(xJittered * 90) - 5}%`;
        post.style.top = `${yJittered * 95}%`;
        post.style.transform = `rotate(${randomRotation}deg)`;

        post.dataset.randomRotation = randomRotation;
    });
}

function clusterPlace(postItems) {
    // Formula for normalized placement with given bounds
    function getNormalizedPosition(index, xBoundMin, xBoundMax, yBoundMin, yBoundMax) {
        index += 1; // Increment index to avoid (0, 0) placement
        let x = (index * 0.245122333753) % 1; // Normalize to [0, 1]
        let y = (index * 0.430159709002) % 1; // Normalize to [0, 1]

        // Normalize to specified bounds
        x = xBoundMin + x * (xBoundMax - xBoundMin);
        y = yBoundMin + y * (yBoundMax - yBoundMin);

        return { x, y };
    }

    const screenWidth = window.innerWidth;
    let xBoundMin, xBoundMax, yBoundMin, yBoundMax;

    // Set bounds based on screen size
    if (screenWidth > 1200) {
        xBoundMin = 0.6;
        xBoundMax = 0.8;
        yBoundMin = 0;
        yBoundMax = 0.4;
    } else {
        xBoundMin = 0;
        xBoundMax = 0.5;
        yBoundMin = 0.1;
        yBoundMax = 0.6;
    }

    const shuffledItems = [...postItems].sort(() => Math.random() - 0.5);

    shuffledItems.forEach((post, index) => {
        const { x, y } = getNormalizedPosition(index, xBoundMin, xBoundMax, yBoundMin, yBoundMax);

        // Apply jitter to x and y, multiplied by 100 as requested
        const xJittered = (x + (Math.random() * 0.05 - 0.025)) * 100;
        const yJittered = (y + (Math.random() * 0.05 - 0.025)) * 100;

        // Set position, no random rotation
        post.style.position = 'absolute';
        post.style.left = `${xJittered - 10}%`;
        post.style.top = `${yJittered}%`;

        // Store the position values in dataset for future reference
        post.dataset.x = x;
        post.dataset.y = y;
    });
}

function hoverSort(postItems, randomSort = false) {
    let sortedPosts = Array.from(postItems).map((post, index) => {
        return {
            post: post,
            index: index,
            top: parseFloat(post.style.top),
            left: parseFloat(post.style.left)
        };
    });

    if (!randomSort) {
        // Sort by top and then by left
        sortedPosts.sort((a, b) => {
            if (a.top === b.top) {
                return a.left - b.left;
            }
            return a.top - b.top;
        });
    } else {
        // Shuffle the posts randomly for random z-index
        sortedPosts.sort(() => Math.random() - 0.5);
    }

    // Assign zIndexes based on sorted/random position
    let zIndexes = sortedPosts.map((_, i) => i + 1);

    sortedPosts.forEach(({ post, index }, sortedIndex) => {
        post.style.zIndex = zIndexes[sortedIndex];

        post.addEventListener('mouseenter', () => {
            post.style.zIndex = 9997;
            post.style.transform = `rotate(0deg)`;

            // Update zIndexes for all posts on hover
            for (let i = 0; i < postItems.length; i++) {
                if (zIndexes[i] > zIndexes[sortedIndex]) {
                    zIndexes[i] -= 1;
                    sortedPosts[i].post.style.zIndex = zIndexes[i];
                }
            }
        });

        post.addEventListener('mouseleave', () => {
            // Access the stored randomRotation
            const randomRotation = post.dataset.randomRotation;
            post.style.transform = `rotate(${randomRotation}deg)`;

            post.style.zIndex = zIndexes[sortedIndex] = postItems.length;

            // Reset zIndexes after hover
            sortedPosts.forEach(({ post }, i) => {
                post.style.zIndex = zIndexes[i];
            });
        });
    });
}

function dragMove(post) {
    post.onmousedown = function(event) {
        const postRect = post.getBoundingClientRect();
        const parentRect = post.parentElement.getBoundingClientRect();

        let shiftX = event.clientX - postRect.left;
        let shiftY = event.clientY - postRect.top;

        function moveAt(pageX, pageY) {
            // Calculate the new position in percentage
            let leftPercent = ((pageX - shiftX - parentRect.left) / parentRect.width) * 100;
            let topPercent = ((pageY - shiftY - parentRect.top) / parentRect.height) * 100;

            // Set the position in %
            post.style.left = `${leftPercent}%`;
            post.style.top = `${topPercent}%`;
        }

        function onMouseMove(event) {
            moveAt(event.pageX, event.pageY);
            post.style.zIndex = 9998;
            post.style.transform = `rotate(0deg)`;
        }

        document.addEventListener('mousemove', onMouseMove);

        post.onmouseup = function() {
            document.removeEventListener('mousemove', onMouseMove);
            post.style.cursor = 'grab';
            post.style.zIndex = 9997;
            post.onmouseup = null;
        };
    };

    post.ondragstart = function() {
        return false;
    };
}

</script>

<!-- image viewer -->
<script>
document.addEventListener('DOMContentLoaded', function () {
const images = document.querySelectorAll('.clickable');
    let overlay, viewerImage, isZoomed = false;

    images.forEach(image => {
        var isDragged = false;
        if (image.classList.contains('movable')) {
            image.style.cursor = `grab`;
            function onMouseMove() {
                isDragged = true;
            }
            image.onmousedown = function(){
                document.addEventListener('mousemove', onMouseMove);
                image.style.cursor = `grabbing`;
            }
            image.onmouseup = function(){
                document.removeEventListener('mousemove', onMouseMove);
                image.style.cursor = `grab`;
                setTimeout(() => {
                isDragged = false;
                }, 100);
            }   
        }
        image.addEventListener('click', function () {
            if (isDragged) {
                return;
            }
            if (!overlay) {
                // Create overlay and viewer image elements
                overlay = document.createElement('div');
                overlay.className = 'image-overlay';
                overlay.style.cursor = 'default';

                viewerImage = document.createElement('img');
                viewerImage.src = image.src;
                viewerImage.className = 'viewer-image';

                const closeMessage = document.createElement('div');
                closeMessage.innerText = 'right-click anywhere to close';
                closeMessage.className = 'close-message';

                const viewerMessage = document.createElement('div');
                const fileName = image.src.split('\\').pop().split('/').pop();
                viewerMessage.innerText = `now viewing: ${fileName} (${image.naturalHeight} x ${image.naturalWidth} pixels) / 1x`;
                viewerMessage.className = 'viewer-message';

                if (image.classList.contains('naps-img')) {
                    viewerImage.classList.add('naps-img');
                    closeMessage.classList.add('binary');
                    viewerMessage.classList.add('binary');
                }

                if (image.classList.contains('carle-img')) {
                    closeMessage.classList.add("carle", "subtitle");
                    viewerMessage.classList.add("carle", "subtitle");
                    overlay.style.backdropFilter = `blur(10px)`;
                }

                overlay.appendChild(closeMessage);
                overlay.appendChild(viewerMessage);
                overlay.appendChild(viewerImage);
                document.body.appendChild(overlay);

                setTimeout(() => {
                    overlay.style.opacity = 1;
                }, 100);

                viewerImage.addEventListener('click', function (e) {
                    e.stopPropagation(); 
                    if (!isZoomed) {
                        const rect = viewerImage.getBoundingClientRect();
                        const percentX = ((e.clientX - rect.left) / rect.width);
                        const percentY = ((e.clientY - rect.top) / rect.height);
                        viewerImage.style.transformOrigin = `${percentX * 100}% ${percentY * 100}%`;

                        viewerImage.classList.add('zoomed');
                        isZoomed = true;
                        overlay.style.cursor = 'zoom-out';
                        viewerImage.style.cursor = 'zoom-out';
                        viewerMessage.innerText = `now viewing: ${fileName} (${image.naturalHeight} x ${image.naturalWidth} pixels) / 2x`;
                    } else {
                        viewerImage.classList.remove('zoomed');
                        isZoomed = false;
                        viewerImage.style.cursor = 'zoom-in';
                        overlay.style.cursor = 'default';
                        viewerMessage.innerText = `now viewing: ${fileName} (${image.naturalHeight} x ${image.naturalWidth} pixels) / 1x`;
                    }
                });
                
                overlay.addEventListener('mousemove', function (e) {
                    if (isZoomed) {
                        const rect = viewerImage.getBoundingClientRect();
                        const percentX = ((e.clientX - rect.left) / rect.width);
                        const percentY = ((e.clientY - rect.top) / rect.height);
                        viewerImage.style.transformOrigin = `${percentX * 100}% ${percentY * 100}%`;
                    }
                });

                function closeViewer() {
                    overlay.style.opacity = 0;
                    setTimeout(() => {
                        document.body.removeChild(overlay);
                        overlay = null;
                        viewerImage = null;
                        isZoomed = false;
                    }, 100);
                };

                // Exit viewer on overlay click
                overlay.addEventListener('click', function () {
                    if (!isZoomed) {
                        closeViewer();
                    } else {
                        viewerImage.classList.remove('zoomed');
                        isZoomed = false;
                        viewerImage.style.cursor = 'zoom-in';
                        overlay.style.cursor = 'default';
                    }
                });

                // Exit viewer on right-click anywhere
                overlay.addEventListener('contextmenu', function (e) {
                    e.preventDefault();
                    closeViewer();
                });
            }
        });
    });
});
</script>